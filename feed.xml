<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://seungyounshin.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://seungyounshin.github.io/" rel="alternate" type="text/html" hreflang="ko"/><updated>2023-12-23T18:38:48+09:00</updated><id>https://seungyounshin.github.io/feed.xml</id><title type="html">Seungyoun Shin(신승윤)</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">dataclasses — 데이터 클래스</title><link href="https://seungyounshin.github.io/blog/2023/python-dataclass/" rel="alternate" type="text/html" title="dataclasses — 데이터 클래스"/><published>2023-12-23T06:01:00+09:00</published><updated>2023-12-23T06:01:00+09:00</updated><id>https://seungyounshin.github.io/blog/2023/python-dataclass</id><content type="html" xml:base="https://seungyounshin.github.io/blog/2023/python-dataclass/"><![CDATA[<p>프로그래밍에서 <code class="language-plaintext highlighter-rouge">interface</code>를 잘 설계하는 것은 코드의 가독성과 유지 보수성을 높일 수 있다.</p> <p>Python 3.7 이상에서 사용할 수 있는 <code class="language-plaintext highlighter-rouge">dataclass</code>는 데코레이터를 통해 클래스 선언을 간소화할 수 있는데 또한 <code class="language-plaintext highlighter-rouge">interface</code> 로서의 역할에도 매우 좋다. 요즘 유행하는 <a href="https://docs.pydantic.dev/latest/">pydantic</a>도 이런 dataclass 에 validation 을 할 수 있는 패키지중 하나이다.</p> <h2 id="dataclass의-기본-사용법">Dataclass의 기본 사용법</h2> <p>C++의 구조체와 유사한 방식으로, Python에서도 간단한 데이터 구조를 빠르게 정의할 수 있는데 x,y 를 가지는 <code class="language-plaintext highlighter-rouge">Point</code> 클래스의 예를 만들어보자.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="n">x</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">y</span><span class="p">:</span> <span class="nb">float</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">dataclass</code> 데코레이터는 <code class="language-plaintext highlighter-rouge">__init__</code>, <code class="language-plaintext highlighter-rouge">__repr__</code>, <code class="language-plaintext highlighter-rouge">__eq__</code> 등의 메서드를 자동으로 추가해준다. 그렇기 때문에 인스턴스를 출력하면</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="nc">Point</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="nc">Point</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
</code></pre></div></div> <p>다음과 같이 깔끔하게 포맷된 결과가 출력된다.</p> <h2 id="transformers-예시"><code class="language-plaintext highlighter-rouge">transformers</code> 예시</h2> <p>오픈소스 모델들을 쉽게 이용할 수 있는 레포인 <a href="https://github.com/huggingface/transformers">transformers</a> 에서도 <code class="language-plaintext highlighter-rouge">Argument</code> 와 모델의 인풋 아웃풋와 같은 interface 를 모두 <code class="language-plaintext highlighter-rouge">dataclass</code> 로 정의해서 사용하고있다.</p> <p>예를 들어 거의 모든 언어모델들의 아웃풋은 <a href="https://github.com/huggingface/transformers/blob/29e7a1e1834f331a4916853ecd58549ed78235d6/src/transformers/modeling_outputs.py#L25"><code class="language-plaintext highlighter-rouge">BaseModelOutput</code></a>를 상속해서 쓰는데 <code class="language-plaintext highlighter-rouge">BaseModelOutput</code> 를 보면</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">BaseModelOutput</span><span class="p">(</span><span class="n">ModelOutput</span><span class="p">):</span>
    <span class="sh">"""</span><span class="s">
</span><span class="gp">    ...</span>
    <span class="sh">"""</span>

    <span class="n">last_hidden_state</span><span class="p">:</span> <span class="n">torch</span><span class="p">.</span><span class="n">FloatTensor</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">hidden_states</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="p">.</span><span class="n">FloatTensor</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">attentions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">torch</span><span class="p">.</span><span class="n">FloatTensor</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>

</code></pre></div></div> <p>와 같이 <code class="language-plaintext highlighter-rouge">BaseModelOutput</code> 의 아웃풋은 보통의 <code class="language-plaintext highlighter-rouge">transformer</code> 구조에서 나올 수 있는 아웃풋들을 포함하는것을 알 수 있다. 이런식으로 Interface 를 datalcass 로 설계하면 우선 코드가 매우 간결해진다. 만약 ABC 클래스로 부터 이런 interface 를 만든다고 한다면 <code class="language-plaintext highlighter-rouge">__init__</code> 부터 여러가지 설계해야할점이 너무나 많고 코드가 방대해진다.</p>]]></content><author><name></name></author><category term="python"/><summary type="html"><![CDATA[an example of a blog post with some code]]></summary></entry></feed>